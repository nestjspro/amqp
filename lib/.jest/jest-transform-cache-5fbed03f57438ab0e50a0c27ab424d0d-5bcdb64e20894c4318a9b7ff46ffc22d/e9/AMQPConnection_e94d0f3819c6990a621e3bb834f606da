0644bf74eb9b4f3374e4b9af1f1969b4
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AMQPConnection = void 0;
const amqp = require("amqplib");
const rxjs_1 = require("rxjs");
const AMQPConnectionStatus_1 = require("./AMQPConnectionStatus");
const chalk = require("chalk");
const AMQPQueue_1 = require("../queueing/AMQPQueue");
const AMQPLogEmoji_1 = require("../logging/AMQPLogEmoji");
const AMQPMessage_1 = require("../queueing/AMQPMessage");
const crypto_1 = require("crypto");
class AMQPConnection {
    constructor(config, logger) {
        this.logger = logger;
        this.status$ = new rxjs_1.ReplaySubject();
        this.reference$ = new rxjs_1.ReplaySubject();
        this.subscriptions = [];
        this.logger.trace(`Instantiating AMQP connection "${chalk.yellowBright(config.name)}"..`, AMQPLogEmoji_1.AMQPLogEmoji.NEW, 'CONNECTION MANAGER');
        this.status = AMQPConnectionStatus_1.AMQPConnectionStatus.DISCONNECTED;
        this.queue = new AMQPQueue_1.AMQPQueue(this);
        this.config = config;
        this.connect();
    }
    connect() {
        this.status$.next(AMQPConnectionStatus_1.AMQPConnectionStatus.CONNECTING);
        this.addSubscription(this.status$.subscribe(status => {
            this.logger.debug(`Connection status changed to ${chalk.greenBright(status)} for connection "${chalk.yellowBright(this.config.name)}".`, AMQPLogEmoji_1.AMQPLogEmoji.SETTINGS, 'STATUS');
            if (status !== AMQPConnectionStatus_1.AMQPConnectionStatus.CONNECTED) {
                this.cancelActiveSubscriptions();
            }
        }));
        try {
            amqp.connect(this.config.url, { timeout: this.config.timeout || 5000 }).then(async (connection) => {
                connection.on('close', () => {
                    this.logger.debug(`Server said: "${chalk.greenBright('CLOSED')}" for connection "${chalk.yellowBright(this.config.name)}".`, AMQPLogEmoji_1.AMQPLogEmoji.SETTINGS, 'SERVER');
                });
                connection.on('error', async (error) => {
                    this.logger.debug(`Server said: "${chalk.greenBright('ERROR')}" for connection "${chalk.yellowBright(this.config.name)}".`, AMQPLogEmoji_1.AMQPLogEmoji.SETTINGS, 'SERVER');
                    await this.reconnect();
                });
                connection.on('blocked', reason => {
                    this.logger.debug(`Server said: "${chalk.greenBright('BLOCKED')}" for connection "${chalk.yellowBright(this.config.name)}".`, AMQPLogEmoji_1.AMQPLogEmoji.SETTINGS, 'SERVER');
                });
                connection.on('unblocked', () => {
                    this.logger.debug(`Server said: "${chalk.greenBright('UNBLOCKED')}" for connection "${chalk.yellowBright(this.config.name)}".`, AMQPLogEmoji_1.AMQPLogEmoji.SETTINGS, 'SERVER');
                });
                connection.on('drain', () => {
                    this.logger.debug(`Server said: "${chalk.greenBright('DRAIN')}" for connection "${chalk.yellowBright(this.config.name)}".`, AMQPLogEmoji_1.AMQPLogEmoji.SETTINGS, 'SERVER');
                });
                connection.on('return', message => {
                    this.logger.debug(`Server said: "${chalk.greenBright('MESSAGE')}" for connection "${chalk.yellowBright(this.config.name)}".`, AMQPLogEmoji_1.AMQPLogEmoji.SETTINGS, 'SERVER');
                });
                const channel = await connection.createChannel();
                await channel.prefetch(!!this.config.prefetch ? this.config.prefetch : 1);
                this.reference = { connection, channel };
                this.reference$.next({ connection, channel });
                this.setStatus(AMQPConnectionStatus_1.AMQPConnectionStatus.CONNECTED);
                this.addSubscription(this.declareResources().subscribe(() => {
                    this.logger.info(`AMQP connection "${chalk.yellowBright(this.config.name)}" is ready!`, AMQPLogEmoji_1.AMQPLogEmoji.SUCCESS, 'CONNECTION MANAGER');
                }));
            });
            return this.reference$;
        }
        catch (e) {
            this.setStatus(AMQPConnectionStatus_1.AMQPConnectionStatus.DISCONNECTED);
            console.log(e);
        }
    }
    async disconnect() {
        this.cancelActiveSubscriptions();
        this.setStatus(AMQPConnectionStatus_1.AMQPConnectionStatus.DISCONNECTED);
        if (this.reference) {
            if (this.reference.channel) {
                await this.reference.channel.close();
            }
            if (this.reference.connection) {
                await this.reference.connection.close();
            }
            this.reference = null;
        }
    }
    async reconnect() {
        await this.disconnect();
        await this.connect();
    }
    tearDown() {
        this.logger.debug(`Tearing down AMQP resources for connection "${chalk.yellowBright(this.config.name)}"..`);
        const subject$ = new rxjs_1.Subject();
        this.reference$.subscribe(async (reference) => {
            for (let i = 0; i < this.config.queues.length; i++) {
                this.logger.debug(`Deleting queue "${this.config.queues[i].name}" on AMQP connection "${this.config.name}"..`, AMQPLogEmoji_1.AMQPLogEmoji.DISCONNECT, 'CONNECTION MANAGER');
                await reference.channel.deleteQueue(this.config.queues[i].name);
            }
            this.logger.debug(`Deleting queue "${this.config.exchange.name}" on AMQP connection "${this.config.name}"..`, AMQPLogEmoji_1.AMQPLogEmoji.DISCONNECT, 'CONNECTION MANAGER');
            await reference.channel.deleteExchange(this.config.exchange.name);
            subject$.next();
        });
        return subject$;
    }
    declareResources() {
        this.logger.debug(`Declaring AMQP resources for connection "${chalk.yellowBright(this.config.name)}"..`, AMQPLogEmoji_1.AMQPLogEmoji.NEW, 'CONNECTION MANAGER');
        const subject$ = new rxjs_1.Subject();
        this.addSubscription(this.reference$.pipe((0, rxjs_1.first)()).subscribe(async (reference) => {
            if (this.status === AMQPConnectionStatus_1.AMQPConnectionStatus.CONNECTED) {
                try {
                    await reference.channel.assertExchange(this.config.exchange.name, this.config.exchange.type, this.config.exchange.options);
                    for (let i = 0; i < this.config.queues.length; i++) {
                        if (this.config.queues[i].createBindings) {
                            await reference.channel.assertQueue(this.config.queues[i].name);
                            this.logger.debug(`Declared the queue "${chalk.yellowBright(this.config.queues[i].name)}" for connection "${chalk.yellowBright(this.config.name)}"..`, AMQPLogEmoji_1.AMQPLogEmoji.SUCCESS, 'CONNECTION MANAGER');
                            await reference.channel.bindQueue(this.config.queues[i].name, this.config.exchange.name, this.config.queues[i].routingKey);
                            this.logger.debug(`Binded the queue "${chalk.yellowBright(this.config.queues[i].name)}" for connection "${chalk.yellowBright(this.config.name)}"..`, AMQPLogEmoji_1.AMQPLogEmoji.SUCCESS, 'CONNECTION MANAGER');
                        }
                    }
                    subject$.next();
                }
                catch (e) {
                }
            }
        }));
        return subject$;
    }
    setStatus(status) {
        this.status = status;
        this.status$.next(status);
    }
    subscribe(subscriber) {
        const subject$ = new rxjs_1.Subject();
        this.reference$.subscribe(reference => {
            reference.channel.consume(subscriber.queue, message => {
                this.logger.debug(`Subscribe emitted deliveryTag #${chalk.yellowBright(message.fields.deliveryTag)} for connection "${chalk.yellowBright(this.config.name)}"..`, AMQPLogEmoji_1.AMQPLogEmoji.SUCCESS, 'CONNECTION MANAGER');
                subject$.next(new AMQPMessage_1.AMQPMessage(message, () => {
                    reference.channel.ack(message);
                }));
                if (!subscriber.noAck) {
                    reference.channel.ack(message);
                }
            });
        });
        return subject$;
    }
    rpcCall(call) {
        const subject$ = new rxjs_1.Subject();
        if (!call.options) {
            call.options = { correlationId: (0, crypto_1.randomUUID)() };
        }
        else if (call.options && !call.options.correlationId) {
            call.options.correlationId = (0, crypto_1.randomUUID)();
        }
        this.reference$.subscribe(reference => {
            this.logger.debug(`Sending RPC call to correlationId #${chalk.yellowBright(call.options.correlationId)} for connection "${chalk.yellowBright(this.config.name)}"..`, AMQPLogEmoji_1.AMQPLogEmoji.SUCCESS, 'CONNECTION MANAGER');
            reference.channel.consume(call.queue, message => {
                console.log(`a: ${message.content.toString()}`);
                subject$.next(new AMQPMessage_1.AMQPMessage(message));
            }, call.options);
            reference.channel.sendToQueue(call.queue, call.message, call.options);
            const timeout = setTimeout(() => {
                console.log('timed out');
            }, call.timeout);
        });
        return subject$;
    }
    rpcConsume(queue, callback, options) {
        const subject$ = new rxjs_1.Subject();
        this.reference$.subscribe(async (reference) => {
            this.logger.debug(`RPC consuming queue "${chalk.yellowBright(queue)}" for connection "${chalk.yellowBright(this.config.name)}"..`, AMQPLogEmoji_1.AMQPLogEmoji.SUCCESS, 'CONNECTION MANAGER');
            await reference.channel.assertQueue(queue, { autoDelete: true });
            reference.channel.consume(queue, message => {
                console.log(message);
                const reply = callback(message);
                console.log(reply);
                reference.channel.sendToQueue(queue, Buffer.from(reply), {
                    correlationId: message.properties.correlationId,
                    replyTo: message.properties.replyTo
                });
            }, options);
        });
        return subject$;
    }
    addSubscription(subscription) {
        this.subscriptions.push(subscription);
    }
    cancelActiveSubscriptions() {
        this.subscriptions.forEach(subscription => subscription.unsubscribe());
    }
}
exports.AMQPConnection = AMQPConnection;
//# sourceMappingURL=AMQPConnection.js.map