[["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/test/AMQPModuleTest.ts",{"fileContent":"import { AMQPService, AMQPModule, AMQPLogLevel, AMQPConnectionStatus } from '../dist';\nimport { TestingModule, Test } from '@nestjs/testing';\n\njest.setTimeout(15000);\n\ndescribe('AMQPModule Test', () => {\n\n    let app;\n\n    test('asdf', async () => {\n\n        const module: TestingModule = await Test.createTestingModule({\n\n            imports: [\n\n                AMQPModule.forRoot({\n\n                    logLevel: AMQPLogLevel.ERROR,\n                    connections: [\n\n                        {\n\n                            name: 'one',\n                            url: 'amqp://rabbitmq:agaeq14@localhost:5672',\n                            exchange: {\n\n                                name: 'test-1',\n                                type: 'topic',\n                                options: {\n\n                                    durable: true\n\n                                }\n\n                            },\n                            queues: [\n\n                                {\n\n                                    name: '1',\n                                    routingKey: '111',\n                                    createBindings: true,\n                                    options: {\n\n                                        durable: false\n\n                                    }\n\n                                }\n\n                            ]\n\n                        }, {\n\n                            name: 'two',\n                            url: 'amqp://rabbitmq:agaeq14@localhost:5672',\n                            exchange: {\n\n                                name: 'test-2',\n                                type: 'topic',\n                                options: {\n\n                                    durable: true\n\n                                }\n\n                            },\n                            queues: [\n\n                                {\n\n                                    name: '2',\n                                    routingKey: '222',\n                                    createBindings: true,\n                                    options: {\n\n                                        durable: false\n\n                                    }\n\n                                }\n\n                            ]\n\n                        }\n\n                    ]\n\n                })\n\n            ]\n\n        }).compile();\n\n        app = module.createNestApplication();\n\n        await app.init();\n\n        const service = module.get(AMQPService);\n\n        service.getConnection('two').subscribe(connection => {\n\n            expect(connection.status).toEqual(AMQPConnectionStatus.DISCONNECTED);\n\n        });\n\n\n        service.disconnect();\n\n        return new Promise<void>(resolve => {\n\n            expect(1).toEqual(1);\n\n            resolve();\n            \n        });\n\n        //\n        // service.connections[ 0 ].reference$.subscribe(reference => {\n        //     console.log(3);\n        //     console.log(reference);\n        //\n        // });\n        // console.log(4);\n        // console.log(service.connections);\n        // await publisher.connect();\n        //\n        // const channel = await publisher.amqp.createChannel();\n        // console.log(channel);\n        // console.log(await channel.assertExchange('test-2', 'topic'));\n        //\n        // await app.close();\n\n\n    });\n\n    afterAll(async () => {\n\n        await app.close();\n\n        return new Promise<void>(resolve => {\n\n            setTimeout(() => {\n\n                resolve();\n\n            }, 1000);\n\n        });\n\n    });\n\n});\n","resolvedModuleNames":["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/index.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPConnection.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPConnectionStatus.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPModule.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPPublisher.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPQueueOptions.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPReference.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPService.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/configuration/AMQPConfig.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/configuration/AMQPConfigConnection.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/configuration/AMQPConfigExchange.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/configuration/AMQPConfigQueue.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/exceptions/AMQPConnectionNotFoundException.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/exceptions/AMQPPublishException.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/logging/AMQPLogEmoji.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/logging/AMQPLogger.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/logging/AMQPLogLevel.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/queueing/AMQPMessage.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/queueing/AMQPQueue.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/queueing/AMQPQueueMessage.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/queueing/AMQPRPCCall.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/queueing/AMQPSubscriber.d.ts"]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/configuration/AMQPConfigQueue.d.ts",{"fileContent":"import { AMQPQueueOptions } from '../AMQPQueueOptions';\nexport interface AMQPConfigQueue {\n    createBindings?: boolean;\n    name: string;\n    routingKey?: string;\n    options?: AMQPQueueOptions;\n}\n","resolvedModuleNames":["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPQueueOptions.d.ts"]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPReference.d.ts",{"fileContent":"import { Connection, Channel } from 'amqplib';\nexport declare class AMQPReference {\n    connection: Connection;\n    channel: Channel;\n}\n","resolvedModuleNames":[]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/decorators/AMQPSubscriber.d.ts",{"fileContent":"import 'reflect-metadata';\nexport declare const AMQPSubscriber: (queue: string) => (target: any, propertyKey: string, descriptor: PropertyDescriptor) => PropertyDescriptor;\n","resolvedModuleNames":[]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/decorators/AMQPDecoratorService.d.ts",{"fileContent":"import { Reflector } from '@nestjs/core';\nexport declare class AMQPDecoratorService {\n    private readonly reflector;\n    constructor(reflector: Reflector);\n}\n","resolvedModuleNames":[]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPLogger.d.ts",{"fileContent":"import { AMQPLogLevel } from './AMQPLogLevel';\nimport * as chalk from 'chalk';\nexport declare class AMQPLogger {\n    static LOG_LEVEL_COLORS: chalk.Chalk[];\n    static log(logLevel: AMQPLogLevel, message: string): void;\n    static error(message: string): void;\n    static info(message: string): void;\n    static debug(message: string): void;\n    static trace(message: string): void;\n}\n","resolvedModuleNames":["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPLogLevel.d.ts"]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPModule.d.ts",{"fileContent":"import { DynamicModule } from '@nestjs/common';\nimport { AMQPConfig } from './configuration/AMQPConfig';\nexport declare class AMQPModule {\n    static forRoot(config: AMQPConfig): DynamicModule;\n}\n","resolvedModuleNames":["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/configuration/AMQPConfig.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/configuration/AMQPConfigConnection.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/logging/AMQPLogLevel.d.ts"]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPLogLevel.d.ts",{"fileContent":"export declare enum AMQPLogLevel {\n    ERROR = 0,\n    INFO = 1,\n    DEBUG = 2,\n    TRACE = 3\n}\n","resolvedModuleNames":[]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/exceptions/AMQPConnectionNotFoundException.d.ts",{"fileContent":"export declare class AMQPConnectionNotFoundException extends Error {\n    constructor(message?: string);\n}\n","resolvedModuleNames":[]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPModuleTest.d.ts",{"fileContent":"export {};\n","resolvedModuleNames":[]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPConfig.d.ts",{"fileContent":"import { AMQPConfigConnection } from './AMQPConfigConnection';\nimport { AMQPLogLevel } from './AMQPLogLevel';\nexport interface AMQPConfig {\n    logLevel?: AMQPLogLevel;\n    connections: Array<AMQPConfigConnection>;\n}\n","resolvedModuleNames":["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPConfigConnection.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPLogLevel.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPConfigQueue.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPConfigExchange.d.ts"]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPConnectionStatus.d.ts",{"fileContent":"export declare enum AMQPConnectionStatus {\n    CONNECTING = \"CONNECTING\",\n    CONNECTED = \"CONNECTED\",\n    DISCONNECTED = \"DISCONNECTED\",\n    DISCONNECTING = \"DISCONNECTING\"\n}\n","resolvedModuleNames":[]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPPublisher.d.ts",{"fileContent":"export declare class AMQPPublisher {\n    amqp: any;\n    connect(): Promise<void>;\n}\n","resolvedModuleNames":[]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/index.d.ts",{"fileContent":"export * from './AMQPConnection';\nexport * from './AMQPConnectionStatus';\nexport * from './AMQPModule';\nexport * from './AMQPPublisher';\nexport * from './AMQPQueueOptions';\nexport * from './AMQPReference';\nexport * from './AMQPService';\nexport * from './configuration/AMQPConfig';\nexport * from './configuration/AMQPConfigConnection';\nexport * from './configuration/AMQPConfigExchange';\nexport * from './configuration/AMQPConfigQueue';\nexport * from './exceptions/AMQPConnectionNotFoundException';\nexport * from './exceptions/AMQPPublishException';\nexport * from './logging/AMQPLogEmoji';\nexport * from './logging/AMQPLogger';\nexport * from './logging/AMQPLogLevel';\nexport * from './queueing/AMQPMessage';\nexport * from './queueing/AMQPQueue';\nexport * from './queueing/AMQPQueueMessage';\nexport * from './queueing/AMQPRPCCall';\nexport * from './queueing/AMQPSubscriber';\n","resolvedModuleNames":["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPConnection.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPConnectionStatus.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPModule.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPPublisher.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPQueueOptions.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPReference.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPService.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/configuration/AMQPConfig.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/configuration/AMQPConfigConnection.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/configuration/AMQPConfigExchange.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/configuration/AMQPConfigQueue.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/exceptions/AMQPConnectionNotFoundException.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/exceptions/AMQPPublishException.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/logging/AMQPLogEmoji.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/logging/AMQPLogger.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/logging/AMQPLogLevel.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/queueing/AMQPMessage.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/queueing/AMQPQueue.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/queueing/AMQPQueueMessage.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/queueing/AMQPRPCCall.d.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/queueing/AMQPSubscriber.d.ts"]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPConfigExchange.d.ts",{"fileContent":"import { Options } from 'amqplib/properties';\nexport interface AMQPConfigExchange {\n    name: string;\n    type: 'direct' | 'topic' | 'headers' | 'fanout' | 'match' | string;\n    options?: Options.AssertExchange;\n}\n","resolvedModuleNames":[]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/logging/AMQPLogEmoji.d.ts",{"fileContent":"export declare enum AMQPLogEmoji {\n    INBOX = \"\\uD83D\\uDCE5\",\n    CONNECTION = \"\\uD83C\\uDFAC \",\n    DISCONNECT = \"\\u2716 \",\n    SUCCESS = \"\\u2705 \",\n    SETTINGS = \"\\u2699 \",\n    NEW = \"\\uD83D\\uDEEB\",\n    DOWN = \"\\uD83D\\uDC8C\"\n}\n","resolvedModuleNames":[]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/AMQPPublishException.d.ts",{"fileContent":"export declare class AMQPConnectionNotFoundException extends Error {\n    constructor(message?: string);\n}\n","resolvedModuleNames":[]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/queueing/AMQPRPCCall.d.ts",{"fileContent":"/// <reference types=\"node\" />\nimport { Options } from 'amqplib';\nimport Publish = Options.Publish;\nexport interface AMQPRPCCall {\n    correlationId?: string;\n    queue: string;\n    message: Buffer;\n    options?: Publish;\n    timeout?: number;\n}\n","resolvedModuleNames":[]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/dist/queueing/AMQPMessage.d.ts",{"fileContent":"import { ConsumeMessage } from 'amqplib';\nexport declare class AMQPMessage<T> {\n    message: ConsumeMessage;\n    ack?: Function;\n    constructor(message: ConsumeMessage, ack?: Function);\n    fromJSON(): T;\n}\n","resolvedModuleNames":[]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/configuration/AMQPConfigQueue.ts",{"fileContent":"import { AMQPQueueOptions } from '../AMQPQueueOptions';\n\nexport interface AMQPConfigQueue {\n\n    createBindings?: boolean;\n    name: string;\n    routingKey?: string;\n    options?: AMQPQueueOptions;\n\n}\n","resolvedModuleNames":["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/AMQPQueueOptions.ts"]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/exceptions/AMQPConnectionNotFoundException.ts",{"fileContent":"export class AMQPConnectionNotFoundException extends Error {\n\n    public constructor(message?: string) {\n\n        super(message);\n\n        this.name = 'AMQPConnectionNotFoundException';\n\n    }\n\n}\n","resolvedModuleNames":[]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/configuration/AMQPConfigConnection.ts",{"fileContent":"import { AMQPConfigQueue } from './AMQPConfigQueue';\nimport { AMQPConfigExchange } from './AMQPConfigExchange';\nimport { AMQPLogLevel } from '../logging/AMQPLogLevel';\nimport { Options } from 'amqplib/properties';\n\nexport interface AMQPConfigConnection {\n\n    name: string;\n    url: string | Options.Connect;\n    exchange: AMQPConfigExchange;\n    queues?: Array<AMQPConfigQueue>;\n    logLevel?: AMQPLogLevel;\n    prefetch?: number;\n    timeout?: number;\n\n}\n","resolvedModuleNames":["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/configuration/AMQPConfigQueue.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/configuration/AMQPConfigExchange.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/logging/AMQPLogLevel.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/AMQPQueueOptions.ts"]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/AMQPModule.ts",{"fileContent":"import { Module, DynamicModule } from '@nestjs/common';\nimport { AMQPConfig } from './configuration/AMQPConfig';\nimport { AMQPService } from './AMQPService';\nimport { AMQPLogger } from './logging/AMQPLogger';\n\n@Module({})\nexport class AMQPModule {\n\n    public static forRoot(config: AMQPConfig): DynamicModule {\n\n        return {\n\n            module: AMQPModule,\n\n            providers: [\n\n                AMQPLogger,\n                AMQPService,\n                {\n\n                    provide: 'AMQP_CONFIG',\n                    useValue: config\n\n                }\n\n            ],\n\n            exports: [\n\n                AMQPService\n\n            ]\n\n        };\n\n    }\n\n}\n","resolvedModuleNames":["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/configuration/AMQPConfig.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/AMQPService.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/logging/AMQPLogger.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/configuration/AMQPConfigConnection.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/logging/AMQPLogLevel.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/AMQPConnection.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/exceptions/AMQPConnectionNotFoundException.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/logging/AMQPLogEmoji.ts"]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/queueing/AMQPQueueMessage.ts",{"fileContent":"import { Subject } from 'rxjs';\nimport { Options } from 'amqplib';\nimport Publish = Options.Publish;\n\nexport interface AMQPQueueMessage {\n\n    exchange: string | number;\n    routingKey: string | number;\n    message: Buffer;\n    options?: Publish;\n\n    published$?: Subject<boolean>;\n\n}\n","resolvedModuleNames":[]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/configuration/AMQPConfigExchange.ts",{"fileContent":"import { Options } from 'amqplib/properties';\n\nexport interface AMQPConfigExchange {\n\n    name: string;\n    type: 'direct' | 'topic' | 'headers' | 'fanout' | 'match' | string;\n    options?: Options.AssertExchange;\n\n}\n","resolvedModuleNames":[]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/configuration/AMQPConfig.ts",{"fileContent":"import { AMQPConfigConnection } from './AMQPConfigConnection';\nimport { AMQPLogLevel } from '../logging/AMQPLogLevel';\n\nexport interface AMQPConfig {\n\n    logLevel?: AMQPLogLevel;\n    connections: Array<AMQPConfigConnection>;\n\n}\n","resolvedModuleNames":["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/configuration/AMQPConfigConnection.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/logging/AMQPLogLevel.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/configuration/AMQPConfigQueue.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/configuration/AMQPConfigExchange.ts"]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/exceptions/AMQPPublishException.ts",{"fileContent":"export class AMQPPublishException extends Error {\n\n    public constructor(message?: string) {\n\n        super(message);\n\n        this.name = 'AMQPPublishException';\n\n    }\n\n}\n","resolvedModuleNames":[]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/logging/AMQPLogLevel.ts",{"fileContent":"export enum AMQPLogLevel {\n\n    ERROR = 0,\n    INFO = 1,\n    DEBUG = 2,\n    TRACE = 3\n    \n}\n","resolvedModuleNames":[]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/queueing/AMQPSubscriber.ts",{"fileContent":"export interface AMQPSubscriber {\n\n    queue: string;\n    noAck?: boolean;\n\n}\n","resolvedModuleNames":[]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/AMQPConnection.ts",{"fileContent":"import * as amqp from 'amqplib';\nimport { Replies } from 'amqplib';\nimport { AMQPConfigConnection } from './configuration/AMQPConfigConnection';\nimport { ReplaySubject, BehaviorSubject, Subject, Subscription, first } from 'rxjs';\nimport { AMQPReference } from './AMQPReference';\nimport { AMQPConnectionStatus } from './AMQPConnectionStatus';\nimport { AMQPLogger } from './logging/AMQPLogger';\nimport * as chalk from 'chalk';\nimport { AMQPQueue } from './queueing/AMQPQueue';\nimport { AMQPLogEmoji } from './logging/AMQPLogEmoji';\nimport { AMQPMessage } from './queueing/AMQPMessage';\nimport { AMQPSubscriber } from './queueing/AMQPSubscriber';\nimport { AMQPRPCCall } from './queueing/AMQPRPCCall';\nimport { randomUUID } from 'crypto';\nimport Consume = Replies.Consume;\n\n/**\n * AMQP individual connection class.\n */\nexport class AMQPConnection {\n\n    /**\n     * Connection status.\n     *\n     * @type {AMQPConnectionStatus}\n     */\n    public status: AMQPConnectionStatus;\n\n    /**\n     * Connection status event change observable.\n     *\n     * @type {BehaviorSubject<AMQPConnectionStatus>}\n     */\n    public status$: ReplaySubject<AMQPConnectionStatus> = new ReplaySubject();\n\n    /**\n     * Connection configuration settings.\n     *\n     * @type {AMQPConfigConnection}\n     */\n    public config: AMQPConfigConnection;\n\n    /**\n     * References to the connection and channel for this connection.\n     *\n     * @type {ReplaySubject<AMQPReference>}\n     */\n    public reference$: ReplaySubject<AMQPReference> = new ReplaySubject();\n    public reference: AMQPReference;\n\n    /**\n     * Queue for managing message delivery.\n     *\n     * @type {AMQPQueue}\n     */\n    public queue: AMQPQueue;\n\n    /**\n     * Maintain a list of active observable subscriptions so\n     * they can be cancelled later in the event of a state change.\n     *\n     * @type {Subscription}\n     * @private\n     */\n    private subscriptions: Array<Subscription> = [];\n\n    /**\n     * AMQP individual connection class constructor (requires a configuration object).\n     *\n     * @param {AMQPConfigConnection} config\n     * @param {AMQPLogger} logger\n     */\n    public constructor(config: AMQPConfigConnection, public readonly logger: AMQPLogger) {\n\n        this.logger.trace(`Instantiating AMQP connection \"${ chalk.yellowBright(config.name) }\"..`, AMQPLogEmoji.NEW, 'CONNECTION MANAGER');\n\n        this.status = AMQPConnectionStatus.DISCONNECTED;\n        this.queue = new AMQPQueue(this);\n        this.config = config;\n\n        this.connect();\n\n    }\n\n    /**\n     * Connect to the AMQP server.\n     *\n     * @returns {ReplaySubject<AMQPReference>}\n     */\n    public connect(): ReplaySubject<AMQPReference> {\n\n        this.status$.next(AMQPConnectionStatus.CONNECTING);\n\n        //\n        // Subscribe to status changes so we can log them.\n        //\n        this.addSubscription(this.status$.subscribe(status => {\n\n            this.logger.debug(`Connection status changed to ${ chalk.greenBright(status) } for connection \"${ chalk.yellowBright(this.config.name) }\".`, AMQPLogEmoji.SETTINGS, 'STATUS');\n\n            if (status !== AMQPConnectionStatus.CONNECTED) {\n\n                this.cancelActiveSubscriptions();\n\n            }\n\n        }));\n\n        try {\n\n            amqp.connect(this.config.url, { timeout: this.config.timeout || 5000 }).then(async connection => {\n\n                connection.on('close', () => {\n\n                    this.logger.debug(`Server said: \"${ chalk.greenBright('CLOSED') }\" for connection \"${ chalk.yellowBright(this.config.name) }\".`, AMQPLogEmoji.SETTINGS, 'SERVER');\n\n                });\n\n                connection.on('error', async error => {\n\n                    this.logger.debug(`Server said: \"${ chalk.greenBright('ERROR') }\" for connection \"${ chalk.yellowBright(this.config.name) }\".`, AMQPLogEmoji.SETTINGS, 'SERVER');\n\n                    await this.reconnect();\n\n                });\n\n                connection.on('blocked', reason => {\n\n                    this.logger.debug(`Server said: \"${ chalk.greenBright('BLOCKED') }\" for connection \"${ chalk.yellowBright(this.config.name) }\".`, AMQPLogEmoji.SETTINGS, 'SERVER');\n\n                });\n\n                connection.on('unblocked', () => {\n\n                    this.logger.debug(`Server said: \"${ chalk.greenBright('UNBLOCKED') }\" for connection \"${ chalk.yellowBright(this.config.name) }\".`, AMQPLogEmoji.SETTINGS, 'SERVER');\n\n                });\n\n                connection.on('drain', () => {\n\n                    this.logger.debug(`Server said: \"${ chalk.greenBright('DRAIN') }\" for connection \"${ chalk.yellowBright(this.config.name) }\".`, AMQPLogEmoji.SETTINGS, 'SERVER');\n\n                });\n\n                connection.on('return', message => {\n\n                    this.logger.debug(`Server said: \"${ chalk.greenBright('MESSAGE') }\" for connection \"${ chalk.yellowBright(this.config.name) }\".`, AMQPLogEmoji.SETTINGS, 'SERVER');\n\n                });\n\n                const channel = await connection.createChannel();\n                await channel.prefetch(!!this.config.prefetch ? this.config.prefetch : 1);\n\n                this.reference = { connection, channel };\n                this.reference$.next({ connection, channel });\n\n                this.setStatus(AMQPConnectionStatus.CONNECTED);\n\n                this.addSubscription(this.declareResources().subscribe(() => {\n\n                    this.logger.info(`AMQP connection \"${ chalk.yellowBright(this.config.name) }\" is ready!`, AMQPLogEmoji.SUCCESS, 'CONNECTION MANAGER');\n\n                }));\n\n            });\n\n            return this.reference$;\n\n        } catch (e) {\n\n            this.setStatus(AMQPConnectionStatus.DISCONNECTED);\n\n            console.log(e);\n\n        }\n\n    }\n\n    /**\n     * Disconnect from the AMQP server.\n     * (This does not remove any resources such as queues, exchanges, etc..)\n     *\n     * @author Matthew Davis <matthew@matthewdavis.io\n     */\n    public async disconnect(): Promise<void> {\n\n        this.cancelActiveSubscriptions();\n\n        this.setStatus(AMQPConnectionStatus.DISCONNECTED);\n\n        if (this.reference) {\n\n            if (this.reference.channel) {\n\n                await this.reference.channel.close();\n\n            }\n\n            if (this.reference.connection) {\n\n                await this.reference.connection.close();\n\n            }\n\n            this.reference = null;\n\n        }\n\n    }\n\n    public async reconnect(): Promise<void> {\n\n        await this.disconnect();\n        await this.connect();\n\n    }\n\n    public tearDown(): Subject<void> {\n\n        this.logger.debug(`Tearing down AMQP resources for connection \"${ chalk.yellowBright(this.config.name) }\"..`);\n\n        const subject$: Subject<void> = new Subject();\n\n        this.reference$.subscribe(async reference => {\n\n            for (let i = 0; i < this.config.queues.length; i++) {\n\n                this.logger.debug(`Deleting queue \"${ this.config.queues[ i ].name }\" on AMQP connection \"${ this.config.name }\"..`, AMQPLogEmoji.DISCONNECT, 'CONNECTION MANAGER');\n\n                await reference.channel.deleteQueue(this.config.queues[ i ].name);\n\n            }\n\n            this.logger.debug(`Deleting queue \"${ this.config.exchange.name }\" on AMQP connection \"${ this.config.name }\"..`, AMQPLogEmoji.DISCONNECT, 'CONNECTION MANAGER');\n\n            await reference.channel.deleteExchange(this.config.exchange.name);\n\n            subject$.next();\n\n        });\n\n        return subject$;\n\n    }\n\n    /**\n     * Declare exchange and queue(s) then setup bindings.\n     *\n     * @author Matthew Davis <matthew@matthewdavis.io>\n     *\n     * @returns {Subject<void>} Observable emitted when complete.\n     */\n    public declareResources(): Subject<void> {\n\n        this.logger.debug(`Declaring AMQP resources for connection \"${ chalk.yellowBright(this.config.name) }\"..`, AMQPLogEmoji.NEW, 'CONNECTION MANAGER');\n\n        const subject$: Subject<void> = new Subject();\n\n        this.addSubscription(this.reference$.pipe(first()).subscribe(async reference => {\n\n            if (this.status === AMQPConnectionStatus.CONNECTED) {\n\n                try {\n\n                    await reference.channel.assertExchange(this.config.exchange.name, this.config.exchange.type, this.config.exchange.options);\n\n\n                    for (let i = 0; i < this.config.queues.length; i++) {\n\n                        if (this.config.queues[ i ].createBindings) {\n\n                            await reference.channel.assertQueue(this.config.queues[ i ].name);\n                            this.logger.debug(`Declared the queue \"${ chalk.yellowBright(this.config.queues[ i ].name) }\" for connection \"${ chalk.yellowBright(this.config.name) }\"..`, AMQPLogEmoji.SUCCESS, 'CONNECTION MANAGER');\n\n                            await reference.channel.bindQueue(this.config.queues[ i ].name, this.config.exchange.name, this.config.queues[ i ].routingKey);\n                            this.logger.debug(`Binded the queue \"${ chalk.yellowBright(this.config.queues[ i ].name) }\" for connection \"${ chalk.yellowBright(this.config.name) }\"..`, AMQPLogEmoji.SUCCESS, 'CONNECTION MANAGER');\n\n                        }\n\n                    }\n\n                    subject$.next();\n\n                } catch (e) {\n\n\n                }\n            }\n\n        }));\n\n        return subject$;\n\n    }\n\n    /**\n     * Change status to a new value.\n     *\n     * @param {AMQPConnectionStatus} status\n     */\n    public setStatus(status: AMQPConnectionStatus): void {\n\n        this.status = status;\n\n        this.status$.next(status);\n\n    }\n\n    /**\n     * Subscribe to a queue returning an observable.\n     *\n     * Message will auto-acknowledge itself when emitted if not disabled.\n     *\n     * @param {AMQPSubscriber} subscriber Subscripton configuration object.\n     *\n     * @return {Subject<AMQPMessage>} Observable emitting new messages on arrival.\n     */\n    public subscribe(subscriber: AMQPSubscriber): Subject<AMQPMessage<any>> {\n\n        const subject$: Subject<AMQPMessage<any>> = new Subject();\n\n        //\n        // Acquire connection reference.\n        //\n        this.reference$.subscribe(reference => {\n\n            //\n            // Start consuming (subscribing) new messages.\n            //\n            reference.channel.consume(subscriber.queue, message => {\n\n                this.logger.debug(`Subscribe emitted deliveryTag #${ chalk.yellowBright(message.fields.deliveryTag) } for connection \"${ chalk.yellowBright(this.config.name) }\"..`, AMQPLogEmoji.SUCCESS, 'CONNECTION MANAGER');\n\n                //\n                // Emit the new message.\n                //\n                subject$.next(new AMQPMessage<any>(message, () => {\n\n                    // Lazy acknowledgement method.\n                    reference.channel.ack(message);\n\n                }));\n\n                //\n                // Automatically acknowledge message if not otherwise set to true.\n                //\n                if (!subscriber.noAck) {\n\n                    reference.channel.ack(message);\n\n                }\n\n            });\n\n        });\n\n        return subject$;\n\n    }\n\n    /**\n     * Perform an RPC call and return the response.\n     *\n     * Before performing the request a new queue will be generated\n     * and subcribe to temporarily.\n     *\n     * **NOTE:** This call is susceptible to a timout (defaults to 5 seconds).\n     *\n     * @param {AMQPRPCCall} call RPC call configuration object.\n     * @return {Subject<any>} Observable which emits a reply of type {T}.\n     */\n    public rpcCall<T>(call: AMQPRPCCall): Subject<AMQPMessage<T>> {\n\n        const subject$: Subject<AMQPMessage<T>> = new Subject();\n\n        //\n        // Calculate correlationId (used for mapping the sender\n        // and receiver of a message across pub/sub sessions).\n        //\n        if (!call.options) {\n\n            call.options = { correlationId: randomUUID() };\n\n        } else if (call.options && !call.options.correlationId) {\n\n            call.options.correlationId = randomUUID();\n\n        }\n\n        //\n        // Acquire the connection reference safely.\n        //\n        this.reference$.subscribe(reference => {\n\n            this.logger.debug(`Sending RPC call to correlationId #${ chalk.yellowBright(call.options.correlationId) } for connection \"${ chalk.yellowBright(this.config.name) }\"..`, AMQPLogEmoji.SUCCESS, 'CONNECTION MANAGER');\n\n            //\n            // Kick off the consumer first.\n            //\n            reference.channel.consume(call.queue, message => {\n\n                console.log(`a: ${ message.content.toString() }`);\n\n                subject$.next(new AMQPMessage<T>(message));\n\n            }, call.options);\n\n            //\n            // Publish the RPC message.\n            //\n            reference.channel.sendToQueue(call.queue, call.message, call.options);\n\n            const timeout = setTimeout(() => {\n\n                console.log('timed out');\n\n            }, call.timeout);\n\n        });\n\n        return subject$;\n\n    }\n\n    public rpcConsume<T>(queue: string, callback: Function, options?: Consume): Subject<T> {\n\n        const subject$: Subject<T> = new Subject();\n\n        this.reference$.subscribe(async reference => {\n\n            this.logger.debug(`RPC consuming queue \"${ chalk.yellowBright(queue) }\" for connection \"${ chalk.yellowBright(this.config.name) }\"..`, AMQPLogEmoji.SUCCESS, 'CONNECTION MANAGER');\n\n            await reference.channel.assertQueue(queue, { autoDelete: true });\n\n            reference.channel.consume(queue, message => {\n\n                console.log(message);\n\n                const reply = callback(message);\n\n\n                console.log(reply);\n                reference.channel.sendToQueue(queue, Buffer.from(reply), {\n\n                    correlationId: message.properties.correlationId,\n                    replyTo: message.properties.replyTo\n\n                });\n\n            }, options);\n\n        });\n\n        return subject$;\n\n    }\n\n    public addSubscription(subscription: Subscription): void {\n\n        this.subscriptions.push(subscription);\n\n\n    }\n\n    public cancelActiveSubscriptions(): void {\n\n        this.subscriptions.forEach(subscription => subscription.unsubscribe());\n\n    }\n\n}\n","resolvedModuleNames":["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/configuration/AMQPConfigConnection.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/AMQPReference.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/AMQPConnectionStatus.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/logging/AMQPLogger.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/queueing/AMQPQueue.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/logging/AMQPLogEmoji.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/queueing/AMQPMessage.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/queueing/AMQPSubscriber.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/queueing/AMQPRPCCall.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/configuration/AMQPConfigQueue.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/configuration/AMQPConfigExchange.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/logging/AMQPLogLevel.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/configuration/AMQPConfig.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/AMQPConnection.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/queueing/AMQPQueueMessage.ts"]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/queueing/AMQPQueue.ts",{"fileContent":"import { AMQPConnection } from '../AMQPConnection';\nimport { Subject, Subscription, Observable, ReplaySubject } from 'rxjs';\nimport { AMQPConnectionStatus } from '../AMQPConnectionStatus';\nimport { AMQPQueueMessage } from './AMQPQueueMessage';\nimport { AMQPLogger } from '../logging/AMQPLogger';\nimport * as chalk from 'chalk';\nimport { AMQPLogEmoji } from '../logging/AMQPLogEmoji';\n\nexport class AMQPQueue {\n\n    private queue$: ReplaySubject<AMQPQueueMessage> = new ReplaySubject();\n    private connection: AMQPConnection;\n    private subscription: Subscription;\n    private readonly logger: AMQPLogger;\n\n    /**\n     * Length of the pending message queue.\n     *\n     * @type {number}\n     */\n    public length: number = 0;\n\n    /**\n     * Maximum number of messages to allow in queue at a time.\n     *\n     * @type {number}\n     */\n    public max: number;\n\n    public subscriptions: Subscription = new Subscription();\n\n    /**\n     * Queue instantiator.\n     *\n     * @param {AMQPConnection} connection Connection reference.\n     * @param {number} max Maximum number of messages to allow in queue at a time.\n     */\n    public constructor(connection: AMQPConnection, max?: number) {\n\n        this.logger = connection.logger;\n        this.connection = connection;\n        this.max = max;\n\n        //\n        // Listen for connection status changes.\n        //\n        this.connection.status$.subscribe(status => {\n\n            //\n            // If we're now connected, drain the queue, otherwise stop listening.\n            //\n            if (status === AMQPConnectionStatus.CONNECTED) {\n\n                this.logger.debug(`${ chalk.greenBright('Connection established') }, queue is ready for drain operations for the connection ${ chalk.yellowBright(this.connection.config.name) }!`, AMQPLogEmoji.SUCCESS, 'QUEUE MANAGER');\n\n                //\n                // Start draining the queue and listening for\n                // additional messages.\n                //\n                this.subscriptions.add(this.queue$.subscribe(messages => this.drain(messages)));\n\n            } else {\n\n                this.subscriptions.unsubscribe();\n\n                this.logger.debug(`${ chalk.greenBright('Connection established') }, queue has stopped draining operations for the connection ${ chalk.yellowBright(this.connection.config.name) }!`, AMQPLogEmoji.DISCONNECT, 'QUEUE MANAGER');\n\n            }\n\n        });\n\n    }\n\n    /**\n     * Subscribes to the queue$ {Subject} and publishes the pending message.\n     *\n     * @param {AMQPQueueMessage} message\n     */\n    public drain(message: AMQPQueueMessage): void {\n\n        this.subscriptions.add(this.connection.reference$.subscribe(reference => {\n\n            this.logger.debug(`${ chalk.redBright('Draining message') } to ${ chalk.yellowBright(message.exchange) }(#${ chalk.blueBright(message.routingKey) }) for the connection \"${ chalk.yellowBright(this.connection.config.name) }\"`, AMQPLogEmoji.DOWN, 'QUEUE MANAGER');\n\n            if (this.connection.status === AMQPConnectionStatus.CONNECTED) {\n\n                // const result = reference.channel.publish(message.exchange.toString(), message.routingKey.toString(), message.message, message.options);\n\n                this.length--;\n\n                //\n                // If the caller passed in an observable, call it to\n                // notify that the message has been published.\n                //\n                // This is beneficial in the event that there is a\n                // long backlog of messages due to connectivity issue(s).\n                //\n                if (message.published$) {\n\n                    // message.published$.next(result);\n\n                }\n\n            }\n\n        }));\n\n    }\n\n    /**\n     * Publish a new message the queue.\n     *\n     * @param {AMQPQueueMessage} message\n     */\n    public publish(message: AMQPQueueMessage): void {\n\n        this.logger.debug(`${ chalk.greenBright('Publishing message') } to ${ chalk.yellowBright(message.exchange) }(#${ chalk.blueBright(message.routingKey) }) for the connection \"${ chalk.yellowBright(this.connection.config.name) }\" (${ this.connection.status === AMQPConnectionStatus.CONNECTED ? chalk.green(this.connection.status) : chalk.red(this.connection.status) })`, AMQPLogEmoji.INBOX, 'QUEUE MANAGER');\n\n        this.queue$.next(message);\n\n        this.length++;\n\n    }\n\n    /**\n     * Helper method to wrap .publish() via arguments.\n     *\n     * @param {string} exchange Exchange to publish message through.\n     * @param {string} routingKey Routing key to publish message under.\n     * @param {Object} message Object that gets serialized into a json string.\n     * @param {Subject<boolean>} published$ Emitted when the messages has been published from the queue.\n     *\n     * @return {Subject<boolean>} Observable that is .next'ed upon completion with the boolean response from amqplib.\n     */\n    public publishJSON(exchange: string | number, routingKey: string | number, message: Object, published$: Subject<boolean> = new Subject()): Observable<boolean> {\n\n        this.publish({\n\n            exchange,\n            routingKey,\n            message: Buffer.from(JSON.stringify(message)),\n            published$\n\n        });\n\n        return published$;\n\n    }\n\n}\n","resolvedModuleNames":["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/AMQPConnection.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/AMQPConnectionStatus.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/queueing/AMQPQueueMessage.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/logging/AMQPLogger.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/logging/AMQPLogEmoji.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/configuration/AMQPConfigConnection.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/AMQPReference.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/queueing/AMQPQueue.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/queueing/AMQPMessage.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/queueing/AMQPSubscriber.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/queueing/AMQPRPCCall.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/logging/AMQPLogLevel.ts","/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/configuration/AMQPConfig.ts"]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/logging/AMQPLogEmoji.ts",{"fileContent":"export enum AMQPLogEmoji {\n\n    INBOX = 'ðŸ“¥',\n    CONNECTION = 'ðŸŽ¬ ',\n    DISCONNECT = 'âœ– ',\n    SUCCESS = 'âœ… ',\n    SETTINGS = 'âš™ ',\n    NEW = 'ðŸ›«',\n    DOWN = 'ðŸ’Œ'\n\n}\n","resolvedModuleNames":[]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/AMQPQueueOptions.ts",{"fileContent":"export interface AMQPQueueOptions {\n\n    exclusive?: boolean | undefined;\n    durable?: boolean | undefined;\n    autoDelete?: boolean | undefined;\n    arguments?: any;\n    messageTtl?: number | undefined;\n    expires?: number | undefined;\n    deadLetterExchange?: string | undefined;\n    deadLetterRoutingKey?: string | undefined;\n    maxLength?: number | undefined;\n    maxPriority?: number | undefined;\n\n}\n","resolvedModuleNames":[]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/AMQPReference.ts",{"fileContent":"import { Connection, Channel } from 'amqplib';\n\nexport class AMQPReference {\n\n    public connection: Connection;\n    public channel: Channel;\n\n}\n","resolvedModuleNames":[]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/queueing/AMQPRPCCall.ts",{"fileContent":"import { Options } from 'amqplib';\nimport Publish = Options.Publish;\n\nexport interface AMQPRPCCall {\n\n    correlationId?: string;\n    queue: string;\n    message: Buffer;\n    options?: Publish;\n    timeout?: number;\n    \n}\n","resolvedModuleNames":[]}],["/Users/matthewdavis/workspace/nestjspro/modules/amqp/lib/src/queueing/AMQPMessage.ts",{"fileContent":"import { ConsumeMessage } from 'amqplib';\n\n/**\n * Message envelope.\n */\nexport class AMQPMessage<T> {\n\n    /**\n     * Original message envelope from the AMQP service.\n     *\n     * @type {ConsumeMessage}\n     */\n    public message: ConsumeMessage;\n\n    /**\n     * Acknowledgement method.\n     * Should be called upon receipt.\n     *\n     * @type {Function}\n     */\n    public ack?: Function;\n\n    /**\n     * Original message envelope & late acknowledgement method.\n     *\n     * @param {ConsumeMessage} message\n     * @param {Function} ack\n     */\n    public constructor(message: ConsumeMessage, ack?: Function) {\n\n        this.message = message;\n        this.ack = ack;\n\n    }\n\n    /**\n     * Deserializes the message.content buffer (string) in to an\n     * objct of type {T}.\n     *\n     * @return {T} message.content as {T}.\n     */\n    public fromJSON(): T {\n\n        return JSON.parse(this.message.content.toString());\n\n    }\n\n}\n","resolvedModuleNames":[]}]]